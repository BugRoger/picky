!!!
%html{ :xmlns => "http://www.w3.org/1999/xhtml", :'xml:lang' => "en", :lang => "en" }
  %head
    %meta{ :'http-equiv' => "Content-type", :content => "text/html; charset=utf-8" }
    %link{ :rel => 'stylesheet', :href => 'basic.css', :type => 'text/css' }
    %link{ :rel => 'stylesheet', :href => 'specific.css', :type => 'text/css' }
    %link{ :rel => 'stylesheet', :href => 'grid.css', :type => 'text/css' }
    %title Picky, the small text search engine in Ruby.
  %body
    .header
      %a{ :href => 'http://github.com/floere/picky' }
        %img{ :style => 'position: fixed; top: -10px; right: 0; border: 0;', :src => 'images/forkme.png', :alt => 'Fork me on GitHub' }
    .picky{ :title => 'Snapshot of Picky, indexing data.' }
    / %code
    /   %pre
    /     %a{ :href => 'http://github.com/floere/picky/raw/master/examples/simple_example/webapp/javascripts/picky.min.js' } Minimized JS (picky.min.js) (9kB)
    / %code
    /   %pre
    /     %a{ :href => 'http://github.com/floere/picky/raw/master/examples/simple_example/webapp/javascripts/picky.source.js.tar' } Source JS (picky.source.js.tar) (45kB)
    .container_2
      %h1 Picky
    .container_2
      %h2 The combinatorial small-text search engine in Ruby.
      .grid_1
        %h2 What's that?
        %h3 Try…
        %p
          A very
          %a{ :href => 'http://picky-simple-example.heroku.com/' } simple example
          with books (using 2 heroku servers).
        %p
          A more
          %a{ :href => 'http://www.twixtel.com/' } complicated example
          with a telephone search.
        %h3 What it is
        %p A small-text search engine (web) service.
        %h3 What it is not
        %p
          A full-text search engine. If you need that, look at
          %a{ :href => 'http://sphinxsearch.com/' } Sphinx
          or
          = succeed('.') do
            %a{ :href => 'http://lucene.apache.org/solr/' } Solr (Lucene)
          They will help.
        %h3 Huh? What's a small-text search engine?
        %p
          A small-text search engine does not operate on huge blobs of text, but instead on smaller, highly categorized text amounts. For example, on varchar database fields.
        %p
          If your data isn't categorized well (like text from a book), then you should instead choose one of the above full-text search engines.
        %h3 Then why use it?
        %p
          Picky helps your user find data which in a full-text search engine would be buried in a heap of results. Also, it lets him do so with a Google-y single search field.
        %p
          Sure the word "peter" is found most often in document #7, but he actually just wants documents by someone with surname "Peter", and not everything related to peters.
        %p
          Picky helps him refine his search by way of a comfortable interface to get exactly what he wants.
        %h3 But why not just use a full-text search engine?
        %p
          Full-Text search engines do one thing especially well: Making full (i.e. uncategorized heaps of) text searchable.
        %p
          For small, highly categorized text, we simply need new ideas. Picky is one of them.
        %p
          Ok, that was my elevator pitch ;)
        %h3 How it works
        %p Hoo boy.
        %h3 See me show (it) off
        %p
          Using a real
          %a{ :href => 'http://twixtel.ch' } telephone search
          as an example.
        %iframe{ :src => "http://player.vimeo.com/video/12614970", :width => "460", :height => "365", :frameborder => "0" }
        %p
          This was at the fantastic
          %a{ :href => 'http://euruko2010.org/' } EuRuKo 2010
          Conference in
          %a{ :href => 'http://www.google.ch/images?q=krakow+poland' } beautiful
          Krakow.
        %h3 Why would one write a search engine in Ruby?
        %p
          It's fast enough and the high level really helped understanding it as it evolved. There are some parts that have been written in pedal-to-the-metal C code.
        %h3 How does it perform?
        %p
          This depends on many factors, but generally we recommend using Picky with a maximum of 120 million data points (we used it there).
          The area under 20 millions is probably best. Your mileage may vary, of course, depending on how many partial indexes you use etc.
        %p
          Indexing is not too fast, and I'd be glad if it were faster. However, you get the full power of Ruby and fully customizable indexing.
        %h3 Where it is
        %p
          Picky lives in a little cave called
          %a{ :href => 'http://github.com/floere/picky' } The Github Repo
          \. He usually pays his rent on time.
        %h3 Why the octopus?
        %p
          Glad you asked. But first, read this
          = succeed('.') do
            %a{ :href => 'http://en.wikipedia.org/wiki/Octopus' } Wikipedia entry about octopuses
          Also,
          = succeed('.') do
            %a{ :href => 'http://www.youtube.com/watch?v=badHUNl2HXU' } a movie
          Finished? I think that sums it up pretty well. And it's cuuute, don't you think? :)
        %p
          But don't call him that. He likes to be called "Octor the Destroyer".
        %h3 Why the license?
        %p
          My former employer and I met halfway, so to speak. I'd have preferred a MIT license.
        %h3 Examples in the wild
        %p
          %a{ :href => 'http://www.twixtel.ch' } TwixTel
          Telephone Book Search Engine
        %h3 Feedback?
        %p Glad to hear it!
        %p
          = succeed(', ') do
            %a{ :href => 'http://github.com/inbox/new/floere' } github (floere)
          = succeed(', ') do
            %a{ :href => 'http://twitter.com/hanke' } twitter (hanke)
          %a{ :href => 'mailto:florian.hanke@gmail.com' } mail (gmail)
      .grid_1
        %h2 Getting started
        %p This takes about 5 minutes. After that, you'll have a running Picky server and a web frontend to play with.
        %h3 Overview
        %p Before we start, the big picture:
        %img{ :src => 'diagrams/basic-overview.png', :width => '480px' }
        %p
          That's the basic setup. The things to remember are:
          %ul
            %li The Picky server calculates IDs for a query.
            %li Your app server renders results for the IDs.
        %p
          Together they are like a small A-Team, something like "Action Search Squad Alpha"! «We've got the results and are heading back to base now, Sir!» Bam!
        %p
          Note that you don't need a Picky client. You could just as well use the results in your Python/Java/PHP app server (If you happen to write a client for one of these, please let me know).
        %h3 Installation
        %p
          Note that Picky only runs on Ruby 1.9. I recommend
          %a{ :href => 'http://rvm.beginrescueend.com/' } RVM
          for installing and managing Ruby versions.
        %code
          %pre
            gem install picky picky-client
        %h3 The server
        %p The server generates a library example, which you can run right away.
        %code
          %pre
            :preserve
              # Generates a directory "app_name"
              # with a new Picky project.
              
              picky project app_name
          %pre
            :preserve
              cd app_name
              bundle install
        %h4 Index the data
        %code
          %pre
            rake index
        %h4 Start the Picky server
        %code
          %pre
            rake start
        %h4 Try a query!
        %code
          %pre
            curl localhost:8080/books/full?query=test
        %p
          Don't worry about the strange looking results!
          The next part (client) will take care of them.
        %p
          If you're interested anyway:
          %a{ :href => 'http://github.com/floere/picky/wiki/results-format-and-structure' } Results (Format & Structure)
        %h3 The client
        %p The client generates an example app for the "library" example backend, using Sinatra.
        %code
        %pre
          :preserve
            # Generates a directory "app_name"
            # with a new Picky Client Webapp project.
            
            picky-client sinatra app_name
        %pre
          :preserve
            cd app_name
            bundle install
        %h4 Start the app server
        %code
          %pre
            unicorn -p 3000
        %h4 Admire your work
        %p
          Go to
          %a{ :href => 'http://localhost:3000/' } http://localhost:3000/
          and try the examples.
        %h3 Your own search
        %p
          You're probably itching to change the example for
          your own data. How do you do this?
        %h4 The server
        %p In the server directory, just type
        %code
          %pre
            rake
        %p and it will tell you where to change the server configuration.
        %h4 The client
        %code
          %pre
            :preserve
              24.10.10: Currently not working as advertised, sorry!
                        In the meantime please see the source code.
        %p
          Go to
          %a{ :href => 'http://localhost:3000/configure' } http://localhost:3000/configure
          and the page will show you how to configure your app server.
        %h3 Need help?
        %p
          Right here. I'm happy to help!
          If something doesn't work, send/gist me your application.rb
          and I'll look into it.
        %p
          = succeed(', ') do
            %a{ :href => 'http://github.com/inbox/new/floere' } github (floere)
          = succeed(', ') do
            %a{ :href => 'http://twitter.com/hanke' } twitter (hanke)
          %a{ :href => 'mailto:florian.hanke@gmail.com' } mail (gmail)
        %p
          There's a Wiki as well:
          %a{ :href => 'http://github.com/floere/picky/wiki' } Picky Wiki
    .container_2#walkthrough
      %h2 Example: A walkthrough through a server and client.
      .grid_1
        %h2 Client
        %p
          This column describes using a few examples how to set up a client and a front end for the picky server, described in the right column.
        %h3 Setup
        %p
          The examples assume you're using a Sinatra/Padrino or Rails app.
        %p
          Start by getting the picky-client gem and adding it to your Gemfile. You could go on without it but it helps a lot.
        %code
          %pre
            :preserve
              gem install picky-client
              
              gem 'picky-client'
        %p
          Don't forget to do a
        %code
          %pre
            bundle update
        %p
          And that's already it for the client setup! Easy, isn't it? The configuration isn't much harder.
      .grid_1
        %h2 Server
        %p
          This column describes using a few examples how to set up the picky server. You can actually read both columns back and forth if you want. Like ping pong. Played by two chinese master ping-pong pandas. (Not by me, then you'd already stop at gem install. And the table would be on fire.)
        %h3 Setup
        %p
          It starts out the same as in the Getting Started section. But this time, we do an actual example picky project called library_search. For that, we use the
        %code
          %pre
            picky project &lt;project name&gt;
        %p
          command that has been installed with the picky gem.
        %code
          %pre
            :preserve
              gem install picky
              
              picky project library_search
              
              cd library_search
              
              bundle install
        %p
          You now have a nice directory (library_search) set up with all the needed Gems, ready to go!
      .grid_2
      .grid_1
        %h3 Configuration (Sinatra/Rails etc. Controller)
        %p
          The Picky client provides an API to access the server. It looks like this:
        %code
          %pre
            :preserve
              # The options define where the Picky server that
              # you have already set up is found.
              # (Haven't set it up yet – see the right column on
              # how to do this, then come back here)
              #
              # Options are:
              #  * host  # e.g. 'localhost'
              #  * port  # e.g. 8080
              #  * path  # e.g. '/books/full'
              #
              Picky::Client::&lt;Full or Live&gt;.new options
        %p
          Usually, what I do is save the Picky client instance in a constant, like FullBooks, or BookSearch.
          This is so I can reuse that instance.
        %p
          Since this configuration is environment specific, it is best – in Rails – to put it into development.rb / production.rb / test.rb.
        %code
          %pre
            :preserve
              # In development.rb:
              #
              FullBooks = Picky::Client::Full.new(
                :host => 'localhost',
                :port => 8080,
                :path => '/books/full'
              )
              LiveBooks = Picky::Client::Live.new(
                :host => 'localhost',
                :port => 8080,
                :path => '/books/live'
              )
        %p
          The FullBooks and LiveBooks constants are ready for use in your controller actions!
        %p
          Please continue below to see how to use the configured searches.
      .grid_1
        %h3 Configuration
        %p
          The most important file in your project is
          %strong app/application.rb
        %p
          It defines how all the indexing and the searching is handled, and even the routing.
        %h4 Define how the indexing works
        %p What characters pass through, which words are removed (stopwords), how is the text tokenized, i.e., split?
        %code
          %pre
            :preserve
              # In app/application.rb, find this stub
              # and adapt the examples.
              #
              indexing.removes_characters(/[^a-zA-Z0-9\s\/\-\"\&\.]/)
              ...
        %h4 Define a few indexes.
        %p It's easy. If you have a filled database table ready, it's even easier.
        %code
          %pre
            :preserve
              # In app/application.rb, find this stub
              # and adapt the examples.
              #
              # Indexes have an identifier, e.g., :books, a source,
              # which is a database table, and a number of fields.
              #
              books_index = index :books,
                Sources::DB.new(
                  'SELECT id, title, author, description FROM books',
                  :file => 'app/db.yml'
                ),
                field(
                  :title, # identifier
                  :qualifiers => [:t, :title],
                  :similarity => Similarity::DoubleLevenshtone.new(3)
                ),
                field(...
        %p
          An index has
          %ol
            %li an identifier (for index directory naming/referencing by Indexes[:identifier]),
            
            %li
              a data source (find out more on
              %a{ :href => 'http://github.com/floere/picky/wiki/Sources-Configuration' } Sources in the Wiki
              ), and
            
            %li
              a number of fields (find out more
              %a{ :href => 'http://github.com/floere/picky/wiki/Fields-Configuration' } Fields in the Wiki
              in the Wiki), and finally,
            
            %li a number of options.
        %h4 Define how querying works, i.e., query text is handled.
        %p
          After having defined the indexing, this is a piece of cake, since it works the same way.
        %code
          %pre
            :preserve
              # In app/application.rb, find this stub
              # and adapt the examples.
              #
              querying.removes_characters(/[^a-zA-Z0-9\s\"\~\*\:]/)
              ...
        %h4 Queries
        %p Define a few queries.
        %code
          %pre
            :preserve
              # In app/application.rb, find this stub
              # and adapt the examples.
              #
              # A full search returns ids, while a live search doesn't.
              #
              # The options define weights which will give bonus points
              # to certain combinations. If only title words are found,
              # a hefty bonus of 6 is given, which is very high.
              #
              # If a title is found before the author, like
              # "the hobbit, tolkien", 3 points are awarded.
              #
              options = {
                :weights => Query::Weights.new([:title] => 6,
                                               [:title, :author] => 3)
              }
              full_search = Query::Full.new(books_index, options)
              live_search = Query::Live.new(books_index, options)

              # It's possible to use multiple indexes in a query.
              #
              multi_search = Query::Full.new(
                               books_index,
                               dvd_index,
                               mp3_index
                             )
        %p
          Find out more in the
          %a{ :href => 'http://github.com/floere/picky/wiki/Queries-Configuration' } Wiki on Query Configuration
        %h4 Map some URL paths
        %p Phew! Almost done :)
        %code
          %pre
            :preserve
              # In app/application.rb, find this stub
              # and adapt the examples.
              #
              # The method "route" maps URL paths to queries.
              # Use regexps or strings to define paths.
              #
              route %r{^/tracks/full} => full_search
              route %r{^/tracks/live} => live_search
        %p
          Find out more in the
          %a{ :href => 'http://github.com/floere/picky/wiki/Routing-configuration' } Wiki on Routing Queries
        %h3 Indexing
        %p Finally! Let picky have a look at the data!
        %code
          %pre
            rake index
        %h3 Gentlemen, start your engines
        %code
          %pre
            rake start
        %p
          will start an Unicorn.
        %h3 Refine!
        %p Define similarity searches, more specific indexes, more searches, etc.
      .grid_2
      .grid_1
        %h3 Usage (Controller)
        %p
          Now that you have defined the constants, let's use them!
        %p
          The client provides a handy #search method, with the signature
          %strong search(options)
          where the options are:
          %ul
            %li query: the query text
            %li offset: the result offset (default 0, only used in Full)
        %code
          %pre
            :preserve
              # In a controller, e.g. the index action:
              #
              def index
                # A Picky client has a search method with some options:
                # * query: The query to be sent to Picky.
                # * offset: An offset on the result ids. # Default is 0.
                #
                results = FullBooks.search :query => 'hello picky'
        %p
          If the server is running, just try it! The results should be a hash with the result data.
        %p
          Now, this is nice, but not very useful, is it? Picky can make that hash a bit more accessible with Picky::Convenience™.
        %code
          %pre
            :preserve
              # Still in the controller action:
              #
              results = FullBooks.search ...
              
              # Make the hash a bit more self-aware.
              #
              results.extend Picky::Convenience
              
              # Now you get:
              #
              results.empty?
              results.ids 10    # First 10 ids. Default is 20.
              results.clear_ids # Remove all ids.
              results.allocations
              results.allocations_size
              results.total     # The total amount of found ids.
              
              # The method I use most often is
              # populate_with, as this populates the results
              # with rendered results (using the ids), not
              # just the ids themselves.
              #
              # Note: Also clears the ids with clear_ids.
              #
              results.populate_with Book do |book| # The model.
                book.to_s # How to render the model.
              end
              
              # If you use the provided Picky JavaScript frontend,
              # then encode it in JSON before sending it off.
              #
              ActiveSupport::JSON.encode results
        %p
          And that was it for the controller. It looks large, but when reduced to the essential lines, it is just this:
        %code
          %pre
            :preserve
              # In an initializer or environment.
              #
              FullBooks = Picky::Client::Full.new ...
              LiveBooks = Picky::Client::Full.new ...
            
              # In a controller action.
              #
              results = FullBooks.search ...
              results.populate_with Book { |book| book.to_s }
              ActiveSupport::JSON.encode results
        %p
          Unbeatably easy, right?
        %p
          If you don't want to render the results in the controller, use #entries to render them in a view and use #populate_with without the rendering block.
        %code
          %pre
            :preserve
              # In a controller action.
              #
              results = FullBooks.search ...
              results.populate_with Book
              
              # In your view:
              #
              results.entries.collect! do |book|
                render book
              end
              ActiveSupport::JSON.encode results
      .grid_1
        %h3 Usage (Of the Server)
        %p
          Either from Sinatra/Rails/Padrino/Camping etc. through the picky client (see left column) or using for example curl to access the json data from the server directly:
        %code
          %pre
            curl 'localhost:8080/books/full?offset=10&query=test'
        %p
          Or access it from any app server in any language. The data you get is JSON, for which lots of good libraries are available.
        %h3 Is something not correctly indexed?
        %code
          %pre
            :preserve
              rake 'try[My Words That Do Not Work]'
        %p Words to find should be indexed in basically the same way as the query processes them.
      .grid_2
      .grid_1
        %h3 The provided JS frontend.
        %p
          Picky provides a html structure which is in turn used by the Picky JS frontend.
        %p
          Add the following line to your views (here in haml glory):
        %code
          %pre
            :preserve
              = Picky::Helper.cached_interface options
        %p or
        %code
          %pre
            :preserve
              = Picky::Helper.interface options
        %p
          The options (defaults after the ||) are
        %code
          %pre
            :preserve
              options[:button]     || 'search'
              options[:no_results] || 'Sorry, no results found!'
              options[:more]       || 'more'
        %p
          This enables you to pass in your own translated texts. If you have only one language I suggest you use #cached_interface.
        %p
          With the HTML structure in place, let's take a look at the Javascript.
        %p
          The simplest example that works is:
        %code
          %pre
            :preserve
              new PickyClient({
                full: '/search/full', // Displays the rendered results.
                live: '/search/live'  // Just updates the count.
              });
        %p
          You'd of course use the urls you want.
        %p
          A more complicated example looks like this:
        %code
          %pre
            :preserve
              pickyClient = new PickyClient({
                // A full query displays the rendered results.
                //
                full: '/search/full',
                
                // A live query just updates the count.
                //
                live: '/search/live',
                
                // Optional. Default is 10.
                //
                showResultsLimit: 20,
                
                // Optional. Before Picky sends any data.
                //
                before: function(params, query, offset) {
                  console.log('Going to send your query. Oh boy!');
                },
                
                // Optional. Just after Picky receives data.
                //           (Get a PickyData object)
                //
                success: function(data, query) {
                  console.log('Received the data.');
                },
                
                // Optional. After Picky has handled the
                //           data and updated the view.
                //
                after: function(data, query) {
                  console.log('Found what you were looking for?');
                },
                
                // This is used to generate the correct query
                // strings, localized. E.g. "subject:war".
                //
                // Optional. If you don't give these, the
                // field identifier given in the Picky server
                // is used.
                //
                qualifiers: {
                  en:{
                    subjects:  'subject'
                  }
                },
                
                // This is used to explain the preceding word
                // in the suggestion text, localized.
                // E.g. "Peter (author)".
                //
                // Optional. Default are the field identifiers
                //           from the Picky server.
                //
                explanations: {
                  en:{
                    title:     'titled',
                    author:    'written by',
                    isbn:      'ISBN-13',
                    year:      'published in',
                    publisher: 'published by',
                    subjects:  'topics'
                  }
                }
              });
              
              // An initial search text.
              //
              pickyClient.insert('initial search text');
        %p
          And that's basically it. Wish you great success!
      .grid_1
        %h3 Usage (Become a Picky master)
        %p 1. An asterisk (*) makes picky search for a partial hit. (If the index supports that)
        %code
          %pre
            part*
        %p also finds partial, party, partogenesology.
        %p 2. The last word in a query is always partially searched.
        %code
          %pre
            my beautiful query
        %p is actually
        %code
          %pre
            my beautiful query*
        %p 3. Asterisk searches can be stopped.
        %code
          %pre
            "part"
        %p only finds "part", and nothing else.
        %p 4. If you have defined a similarity index on a field, a tilde (~) will look for similar matches.
        %code
          %pre
            my beoootiful~ query
        %p will also find your "beautiful" query.
        %p 5. Qualifiers can be used with a colon (:)
        %code
          %pre
            title:ulysses author:joyce
        %p will narrow the search space to complex novels.
        %p 6. The above options can be combined.
        %code
          %pre
            name:flurion~ hank*
        %p will find me.
        %p That is all, young grasshopper. Be on your way.
      .grid_2
      .grid_1
        %h2 Some insight into the life of Picky
        %h3 The user interface
        %h3 Guessing the user's intent
      .grid_1
        %h2 Roadmap
        %p
          %a{ :href => 'http://github.com/floere/picky/wiki/Roadmap' } Wiki Roadmap
      .grid_2
        .decoration
    .footer